<!doctype html>
<html lang="zh-cn">

<head>
	
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>test | test</title>
<link rel="stylesheet" href="/_static/style.css">
<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.8.0/github-markdown.min.css"
	integrity="sha512-MN7ZIXx1ti80exC9cQBaKjC+lbTegJWs/u8KGPGIhJj0/Zyc4UtgWeOp4R8jpfrMUMYf6WJ5sAPbCbwe9S+t6g=="
	crossorigin="anonymous" referrerpolicy="no-referrer" /> -->

<link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'"
	href="https://cdnjs.cloudflare.com/ajax/libs/prism-themes/1.9.0/prism-a11y-dark.min.css">
<noscript>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism-themes/1.9.0/prism-coldark-dark.min.css">
</noscript>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script defer
	src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script defer
	src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css"
	integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"
	integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg"
	crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
	integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk"
	crossorigin="anonymous"></script>
<script>
	document.addEventListener("DOMContentLoaded", function () {
		const inlineMathElements = document.querySelectorAll('span.math-inline');
		const displayMathElements = document.querySelectorAll('span.math-display');

		try {
			inlineMathElements.forEach(el => {
				katex.render(el.textContent.trim(), el, {
					displayMode: false
				});
			});
			displayMathElements.forEach(el => {
				katex.render(el.textContent.trim(), el, {
					displayMode: true
				});
			});
		} catch (err) {
			console.error('公式渲染错误:', err);
		}
	});
</script>
</head>

<body class="flex flex-col font-serif dark:bg-base line-height-normal">
	<header class="shadow print:hidden">
	<nav class="max-w-6xl mx-auto">
		<div class="flex items-center justify-between ">
			<div class="pl-2 flex items-center space-x-4">
				<img src="https://files.rogery.dev/me/icon-128.png" alt="Roger's avatar"
					class="w-11 h-11 rounded-full border-solid border-2 border-stone-300 transition transition-duration-500 hover:transform-rotate-720" />
				<a class="decoration-none color-base color-initial font-bold" href="/">Wiki</a>
			</div>
			<div class="sm:hidden">
				<button class="p-4 text-6 justify-center hover:bg-stone-200 inline-flex items-center ">
					<span class="i-ph-list">xx</span>
				</button>
			</div>
			<nav class="hidden sm:block">
				<ul>
					<a class="p-4 font-medium inline-block hover:bg-stone-200 decoration-none color-initial" href="/">Home</a>
					<a class="p-4 font-medium inline-block hover:bg-stone-200 decoration-none color-initial" href="/post">Articles</a>
					<a class="p-4 font-medium inline-block hover:bg-stone-200 decoration-none color-initial" href="/about">About</a>
				</ul>
			</nav>
		</div>
	</nav>
</header>
	<main class="flex-1 px-4">
<article class="py-20">
  <div class="article mx-auto"><h1>浅谈生成函数 (Generating Function) - Elegia</h1>
<p>本文原链接：<a href="https://www.luogu.com/article/atgvt10i" target="_blank">旧文补档 2018.7.31</a>。</p>
<h2>概念</h2>
<p>本章讨论的生成函数指在某个环上的形式幂级数 (Formal Power Series) <span class="math math-inline">R[[z]]</span>，也可表示为 <span class="math math-inline">R^{\mathbb N}</span>。</p>
<h2>运算</h2>
<p>一个数列 <span class="math math-inline">\langle a_0, a_1, \dots \rangle</span> 的普通型生成函数 (Ordinary Generating Function) 为
<span class="math math-display">
f(z) = \sum_{n=0}^{\infty} a_n z^n
</span>
我们为了简化书写和保持形式的美感，一般情况下 <span class="math math-inline">0^0 = 1</span>。</p>
<h3>加法</h3>
<p>首先我们可以导出加减运算的意义。</p>
<p><span class="math math-inline">\langle a_0 \pm b_0, a_1 \pm b_1, \dots \rangle</span> 的生成函数为</p>
<p><span class="math math-display">
h(z) = f(z) \pm g(z)
</span></p>
<p>其系数表达可以在 <span class="math math-inline">\Theta(n)</span> 的时间内算出。</p>
<h3>乘法</h3>
<p>生成函数相乘对应数列的卷积运算。
<span class="math math-display">
h(z) = f(z)g(z)
</span>
<span class="math math-display">
c_n = \sum_{i=0}^n a_ib_{n-i}
</span>
其系数表达可以通过快速傅里叶变换在 <span class="math math-inline">\Theta(n\log n)</span> 的时间内算出。</p>
<p>特别地，乘法可以借助表示数列的移位，即 <span class="math math-inline">g(z) = z^kf(z)</span> 则我们有
<span class="math math-display">
b_n = a_{n-k}
</span>
除法通过乘法的逆元从而定义，所有常数项不为 0 的数列的生成函数都有对应的逆元。</p>
<p>其系数表达取同余 <span class="math math-inline">z^n</span> 的部分可以在 <span class="math math-inline">\Theta(n\log n)</span> 的时间内算出。</p>
<p>对于一些在数学中常见的函数，其泰勒级数 (Taylor Series) 是在形式演算中总是有意义的，即使在某些地方不收敛。由此我们可以找到一些特别的数列的生成函数。
<span class="math math-display">
\begin{aligned}
\langle 1, 1, \dots \rangle &amp;: &amp; \frac 1{1-z} \\
\left\langle 1, \frac 1 {1!}, \frac 1 {2!}, \dots \right\rangle &amp;: &amp; {\mathrm{e}} ^z \\
\left\langle 0, \frac 1 1, -\frac 1 2, \frac 1 3, -\frac 1 4, \dots \right\rangle &amp;: &amp; \ln (1 + z)
\end{aligned}
</span>
一些函数对应的数列也可以通过求导得到，即 <span class="math math-inline">[z^n]f(z) = \frac 1{n!} f^{(n)}(0)</span>，但也有另一种借助 Cauchy 积分的方法（Cauchy’s Residue Theorem）。
<span class="math math-display">
[z^n]f(z) = \frac 1 {2\pi\mathrm{i}} \oint_{|z| = r} \frac{f(z){\,\mathrm{d}} z}{z^{n + 1}}
</span>
（例：交错不等关系排列计数 <span class="math math-inline">\Leftrightarrow</span> <span class="math math-inline">\tan</span> 函数 <span class="math math-inline">\Leftrightarrow</span> Riemann <span class="math math-inline">\zeta</span> 函数）</p>
<p>函数的求导也可以对应多项式的求导。</p>
<p><span class="math math-display">
\begin{aligned}
\langle a_1, 2a_2, \dots \rangle &amp;: &amp; f&#39;(z) \\
\left\langle 0, a_0, \frac 1 2 a_1, \dots \right\rangle &amp;: &amp; \int_0^z f(t){\,\mathrm{d}} t
\end{aligned}
</span></p>
<h3>Lagrange 反演</h3>
<p>当一个函数满足 <span class="math math-inline">z = f(w)</span> 时，我们有其逆函数 <span class="math math-inline">w = g(z)</span> 的展开式即进行 Lagrange 反演 (Lagrange Inversion)
<span class="math math-display">
[z^n]g(z) = \frac 1n[w^{n-1}]\left( \frac w{f(w)} \right)^n
</span>
以及其扩展形式：
<span class="math math-display">
[z^n]h(g(z)) = \frac1n [w^{n-1}] h&#39;(w)\left( \frac w{f(w)} \right)^n
</span></p>
<h3><span class="math math-inline">k</span> 叉树</h3>
<p>因为 Lagrange 反演不允许常数项有值，所以我们的方程不允许单独的空树：
<span class="math math-display">
T(z) = z(1 + T(z))^k
</span>
我们有
<span class="math math-display">
z = \frac{T(z)}{(1 + T(z))^k}
</span>
即有逆函数
<span class="math math-display">
f(w) = \frac{w}{(1 + w)^k}
</span>
故有
<span class="math math-display">
[z^n]T(z) = \frac 1n \binom{nk}{n - 1}
</span>
只需根据组合数的性质稍作调整即可符合 <span class="math math-inline">n = 0</span> 的情况：
<span class="math math-display">
\frac{\binom{nk}{n}}{n(k - 1) + 1}
</span></p>
<h3>二项式</h3>
<p>牛顿二项式是对于二项式定理的扩展，让指数可以不是非负整数。</p>
<p><span class="math math-display">
(1 + z)^\alpha = \sum_{n = 0}^{\infty} \binom{\alpha}{n} z^n
</span></p>
<p>这里的二项式系数是</p>
<p><span class="math math-display">
\binom{\alpha}{n} = \frac{\alpha (\alpha - 1) \cdots (\alpha - n + 1)}{n!}
</span></p>
<h3>证明 Lucas 定理</h3>
<p>即记 <span class="math math-inline">\cdots n_2 n_1 n_0</span> 为 <span class="math math-inline">n</span> 的 <span class="math math-inline">p</span> 进制表示，则
<span class="math math-display">
\binom{n}{m} \equiv \binom{n_0}{m_0} \binom{n_1}{m_1} \cdots \pmod p
</span>
首先通过 <span class="math math-inline">p</span> 是质数推导出
<span class="math math-display">
0 &lt; n &lt; p \Rightarrow \left. p \middle \vert \binom{p}{n}\right.
</span>
于是有</p>
<p><span class="math math-display">
(1+z)^p \bmod p = 1 + z^p
</span></p>
<p>进一步归纳得到</p>
<p><span class="math math-display">
(1+z)^{p^k} \bmod p = 1 + z^{p^k}
</span></p>
<p>即可得到结论。</p>
<h4>推导 Catalan 数列的通项公式</h4>
<p>考虑 Catalan 数由组合意义导出的一个递推式</p>
<p><span class="math math-display">
\sum_{i = 0}^n C_iC_{n - i} = C_{n + 1}
</span></p>
<p>这个式子是卷积之后右移一位，因此可以得到 Catalan 数的 OGF</p>
<p><span class="math math-display">
c(z) = zc(z)^2 + 1
</span></p>
<p>其中的 <span class="math math-inline">+1</span> 是为了补上初始项。</p>
<p>接下来我们解出两个解</p>
<p><span class="math math-display">
c(z) = \frac{1 \pm \sqrt{1 - 4z}}{2z}
</span></p>
<p>但取正号时如果要求 <span class="math math-inline">c(0)</span> 则会发生非 0 数除以 0，这是必然不符合条件的，因此舍去正号，得到</p>
<p><span class="math math-display">
c(z) = \frac{1 - \sqrt{1 - 4z}}{2z}
</span></p>
<p>我们用牛顿二项式展开</p>
<p><span class="math math-display">
\begin{aligned}
\frac{1 - \sqrt{1 - 4z}}{2z} &amp; = -\frac{\sum_{n = 1}^\infty \binom{\frac 1 2}{n}(-4z)^n}{2z} \\
&amp; = \sum_{n = 0}^\infty 2\binom{\frac 1 2}{n + 1} (-4z)^n \\
&amp; = \sum_{n = 0}^\infty 2\frac{\frac 1 2\left(\frac 1 2 - 1\right)\cdots \left(\frac 1 2 - n\right)}{(n + 1)!} (-4z)^n \\
&amp; = \sum_{n = 0}^\infty \frac{\left(n - \frac 1 2\right)\cdots \left(2 -\frac 3 2\right) \left(1 - \frac 1 2\right)}{(n + 1)!} (4z)^n \\
&amp; = \sum_{n = 0}^\infty \frac{(2n - 1)(2n - 3)\cdots 1}{(n + 1)!} (2z)^n \\
&amp; = \sum_{n = 0}^\infty \frac{(2n)!}{n!(n + 1)!}z^n
\end{aligned}
</span></p>
<h3>前缀和</h3>
<p>如果希望将数列进行前缀和 <span class="math math-inline">b_n = \sum_{i=0}^n a_i</span>，考虑这是一个卷积形式，即另一部分总是 1，那么可以得到</p>
<p><span class="math math-display">
g(z) = \frac 1{1 - z} f(z)
</span></p>
<p>相反地，差分函数则是 <span class="math math-inline">1 - z</span>。</p>
<p>对一个数列做 <span class="math math-inline">k</span> 次前缀和，那么用于卷积的辅助函数 <span class="math math-inline">\frac 1 {1 - z}</span> 就被乘了 <span class="math math-inline">k</span> 次，由牛顿二项式可以得到</p>
<p><span class="math math-display">
\begin{aligned}
\left(\frac 1 {1 - z}\right)^k &amp; = (1 - z)^{-k} \\
&amp; = \sum_{n = 0}^\infty \binom{-k}{n} (-z)^n \\
&amp; = \sum_{n = 0}^\infty \frac{(-k)(-k - 1)\cdots(-k - n + 1)}{n!} (-z)^n \\
&amp; = \sum_{n = 0}^\infty \frac{(k + n - 1)\cdots(k + 1)k}{n!} z^n \\
&amp; = \sum_{n = 0}^\infty \binom{n + k - 1}{k - 1} z^n
\end{aligned}
</span></p>
<h3>变换</h3>
<p>带入 <span class="math math-inline">f(x^k)</span> 可以将数列拉伸，如 <span class="math math-inline">f(x^2)</span> 可以得到 <span class="math math-inline">\langle a_0, 0, a_1, 0, a_2, \dots \rangle</span>。</p>
<p>如果我们想得到 <span class="math math-inline">\langle a_0, 0, a_2, 0, a_4, \dots \rangle</span> 则可以根据奇函数和偶函数的性质构造</p>
<p><span class="math math-display">
g(z) = \frac{f(z) + f(-z)}{2}
</span></p>
<p>这利用到了 <span class="math math-inline">1^n + (-1)^n</span> 的周期性，如果我们想要得到</p>
<p><span class="math math-display">
b_n = \begin{cases}
a_n &amp; \text{if}\quad n \equiv r \pmod m \\
0 &amp; \text{otherwise}
\end{cases}
</span></p>
<p>则可以类比傅里叶变换得到</p>
<p><span class="math math-display">
g(z) = \frac 1 m \sum_{k = 0}^{m - 1} \omega_m^{-kr}f(\omega_m^k z)
</span></p>
<p>其中 <span class="math math-inline">\omega</span> 任取一个 <span class="math math-inline">m</span> 次主根，例如 <span class="math math-inline">\omega = {\mathrm{e}}^{\frac{2\pi\mathrm{i}}m}</span> 。</p>
<p>遗憾的是，这个主根在某些环上可能不存在。</p>
<h4>常系数递推</h4>
<p>生成函数的方法可以帮助我们从另一种层面理解特征方程。</p>
<p>以斐波那契数列为例，由递推方程 <span class="math math-inline">F_n = F_{n - 1} + F_{n - 2}</span> 我们可以对应列出位移方法</p>
<p><span class="math math-display">
f(z) = z + zf(z) + z^2f(z)
</span></p>
<p>因此我们得到其生成函数</p>
<p><span class="math math-display">
f(z) = \frac z{1 - z - z^2}
</span></p>
<p>我们只需要解出 <span class="math math-inline">1 - z - z^2 = 0</span> 的根，根据裂项就可以将其化简成几个形如 <span class="math math-inline">\frac 1{1 - qz}</span> 的运算了。</p>
<p>那么根据一元二次方程的求根公式我们得到两根</p>
<p><span class="math math-display">
\phi = \frac{1 + \sqrt 5}2, \varphi = \frac{1 - \sqrt 5}2
</span></p>
<p>那么由根系关系我们知道了 <span class="math math-inline">z^2 + z - 1 = (z - \phi)(z - \varphi)</span></p>
<p>将原式裂开</p>
<p><span class="math math-display">
\begin{aligned}
f(z) &amp; = \frac z{1 - z - z^2} \\
&amp; = -\frac z{(z - \phi)(z - \varphi)} \\
&amp; = \frac z{\phi - \varphi} \left(\frac 1{z - \phi} - \frac 1{z - \varphi}\right) \\
&amp; = \frac z{\phi - \varphi} \sum_{n = 0}^\infty (\varphi^{-n - 1} - \phi^{-n - 1})z^n
\end{aligned}
</span></p>
<p>因此我们得到了</p>
<p><span class="math math-display">
F_n = \frac{\varphi^{-n} - \phi^{-n}}{\phi - \varphi}
</span></p>
<h3>整数划分数列</h3>
<p>记 <span class="math math-inline">P_n</span> 为 <span class="math math-inline">n</span> 可以无序拆分成若干的正整数的方案。</p>
<p>我们计数一个划分中用到了几个 <span class="math math-inline">k</span>，那么可以写出生成函数</p>
<p><span class="math math-display">
p(z) = (1 + z + z^2 + \cdots)(1 + z^2 + z^4 + \cdots)(1 + z^3 + z^6 + \cdots)\cdots
</span></p>
<p>这可以化简为</p>
<p><span class="math math-display">
p(z) = \prod_{k = 1}^\infty \frac 1{1 - z^k}
</span></p>
<p>而 <span class="math math-inline">\phi(z) = \prod_{k = 1}^\infty (1 - z^k)</span> 的数列被称为五边形数，Euler 给出了其展开式</p>
<p><span class="math math-display">
\prod_{k = 1}^\infty (1 - z^k) = 1 + \sum_{k = 1}^\infty (-1)^k \left[z^{\frac{k(3k + 1)}2} + z^{\frac{k(3k - 1)}2}\right]
</span></p>
<p>其取值十分稀疏，直接求逆也可当做递推式，复杂度为 <span class="math math-inline">\Theta(n\sqrt n)</span>，使用多项式牛顿迭代法求逆复杂度为 <span class="math math-inline">\Theta(n\log n)</span></p>
<h3>下降幂</h3>
<p>定义下降幂</p>
<p><span class="math math-display">
x^ {\underline n} = x(x - 1)\cdots(x - n + 1)
</span></p>
<p>下降幂和方幂可通过斯特林数系数转换</p>
<p><span class="math math-display">
x^{\underline n} = \sum_{k = 0}^n (-1)^{n - k}{\left[n \atop k\right]} x^k
</span></p>
<p>一般 <span class="math math-inline">s(n, k) = (-1)^{n - k}{\left[n \atop k\right]}</span> 被称为有标号第一类斯特林数。</p>
<p>而对于类似的上升幂则更简略，且可以通过组合意义的考量发现该式推出该式是正确的</p>
<p><span class="math math-display">
x^{\overline n} = x(x + 1)\cdots(x + n - 1) = \sum_{k = 0}^n {\left[n \atop k\right]} x^k
</span></p>
<p>事实上这几个结论可以通过几个简单的变换证明等价。</p>
<p>将方幂转为下降幂则是</p>
<p><span class="math math-display">
x^n = \sum_{k = 0}^n {n \brace k} x^{\underline k}
</span></p>
<p>转为上升幂则出现有标号第二类斯特林数</p>
<p><span class="math math-display">
x^n = \sum_{k = 0}^n (-1)^{n - k} {n \brace k} x^{\overline k}
</span></p>
<h2>指数型生成函数</h2>
<p>对于处理一类组合问题的时候，通常遇到的乘积可能是这样</p>
<p><span class="math math-display">
c_n = \sum_{i = 0}^n \binom{n}{i} a_ib_{n - i}
</span></p>
<p>经过变形</p>
<p><span class="math math-display">
\frac{c_n}{n!} = \sum_{i = 0}^n \frac{a_ib_{n - i}}{i!(n - i)!}
</span></p>
<p>发现在运算过程中适合如此定义其生成函数</p>
<p><span class="math math-display">
f(z) = \sum_{n = 0}^\infty a_n\frac{z^n}{n!}
</span></p>
<p>这种生成函数被称为数列的指数型生成函数 (Exponential Generating Function)</p>
<p>而这种情况下，数列 <span class="math math-inline">\langle 1, 1, \dots \rangle</span> 的生成函数是 <span class="math math-inline">{\mathrm{e}}^z</span>，相应地有些运算律也有变化。接下来展示一个简单的例子体现如何使用指数型生成函数来解决一个组合问题。</p>
<p>在一条长为 <span class="math math-inline">n</span> 的方格上涂色，有红黄蓝三种，其中红色必须出现一次，黄色必须出现偶数次，蓝色最多出现一次。
z
这三个不同颜色独立出现的方案的 EGF 分别是 <span class="math math-inline">{\mathrm{e}}^z - 1, \frac{{\mathrm{e}}^z + {\mathrm{e}}^{-z}}2, 1 + z</span>。因此整体方案数就是三种颜色组合相乘</p>
<p><span class="math math-display">
({\mathrm{e}}^z - 1) \cdot \frac{{\mathrm{e}}^z + {\mathrm{e}}^{-z}}2 \cdot (1 + z)
</span></p>
<p>注意到化简的式子形如 <span class="math math-inline">{\mathrm{e}}^{qz}</span> 对应的数列是 <span class="math math-inline">\langle q^n \rangle</span>，而 <span class="math math-inline">z{\mathrm{e}}^{qz}</span> 对应的是 <span class="math math-inline">\langle nq^{n - 1} \rangle</span></p>
<p>化简后可得方案为</p>
<p><span class="math math-display">
a_n = \frac 12 \left(2^n - 1 + [n = 0] - (-1)^n + n2^{n - 1} - n + [n = 1] + n(-1)^n \right)
</span></p>
<h3>集合划分</h3>
<p><span class="math math-inline">\mathrm{Bell}_n</span> 数列是 <span class="math math-inline">n</span> 个元素的无序集合划分的数量，而第二类 Stirling 数 <span class="math math-inline">{n \brace k}</span> 是 <span class="math math-inline">n</span> 个元素被划分至 <span class="math math-inline">k</span> 个非空集合的方案数量，通过 EGF 我们可以轻松得到它们的生成函数。</p>
<p>首先考虑这 <span class="math math-inline">n</span> 个元素被分成了多少个集合，而每个集合非空则 EGF 为 <span class="math math-inline">{\mathrm{e}}^z - 1</span>，如果分成了 <span class="math math-inline">m</span> 个集合，那么我们可以得到生成函数</p>
<p><span class="math math-display">
\sum_{n = 0}^\infty {n \brace k} \frac{z^n}{n!} = \frac{({\mathrm{e}}^z - 1)^k}{k!}
</span></p>
<p>这意味着我们给每个元素染上了一个颜色的同时保证每个颜色至少染了一个元素。最后除以 <span class="math math-inline">k!</span> 则对颜色的序去重。</p>
<p>对这个式子应用二项式定理展开</p>
<p><span class="math math-display">
\frac 1{k!} \sum_{j = 0}^k \binom{k}{j} (-1)^{k - j} {\mathrm{e}}^{jz}
</span></p>
<p>之后得到的就是我们熟悉的容斥法计算第二类 Stirling 数</p>
<p><span class="math math-display">
{n \brace k} = \frac 1{k!}\sum_{j = 0}^k (-1)^{k - j} \binom{k}{j} j^n
</span></p>
<p>而对于 Bell 数来说，不限制集合数量，所以是对于所有不同 <span class="math math-inline">k</span> 的第二类 Stirling 数的生成函数之和</p>
<p><span class="math math-display">
\begin{aligned}
B(z) &amp; = \sum_{k = 0}^\infty \frac{({\mathrm{e}}^z - 1)^k}{k!} \\
&amp; = {\mathrm{e}}^{{\mathrm{e}}^z - 1}
\end{aligned}
</span></p>
<p>由多项式牛顿迭代，通过多项式 <span class="math math-inline">\exp</span> 可以在 <span class="math math-inline">\Theta(n\log n)</span> 的时间内算出 <span class="math math-inline">1 \sim n</span> 内的所有 Bell 数。</p>
<h3>第一类 Stirling 数</h3>
<p>类比集合，圆排列的特点在于第一个位置是灵活的，因此单个圆排列数列应当是 <span class="math math-inline">\langle (n-1)! \rangle</span>，其 EGF 为</p>
<p><span class="math math-display">
\sum_{n = 1}^\infty (n - 1)! \frac{z^n}{n!} = \sum_{n = 1}^\infty \frac {z^n}n
</span></p>
<p>系数为倒数令我们想起对数函数 <span class="math math-inline">\ln(1 + z) = \sum_{n = 1}^\infty \frac 1 n (-1)^{n - 1}z^n</span>，所以可以得到我们想要的函数为</p>
<p><span class="math math-display">
-\ln(1 - z) = \ln \frac 1{1 - z}
</span></p>
<p><span class="math math-display">
\sum_{n = 0}^\infty {\left[n \atop k\right]} \frac{z^n}{n!} = \frac{\left(\ln \frac 1{1-z}\right)^k}{k!}
</span></p>
<h3>二项式反演 (Binomial Inversion)</h3>
<p>当两个数列满足关系</p>
<p><span class="math math-display">
b_n = \sum_{i = 0}^n \binom{n}{i} a_i
</span></p>
<p>时，我们称这是一个二项式变换 (Binomial Transform)，可以用二项式定理证明反演</p>
<p><span class="math math-display">
a_n = \sum_{i = 0}^n (-1)^{n - i}\binom n i b_i
</span></p>
<p>但究其原因，我们发现两个数列的 EGF 由前者等式得到的是</p>
<p><span class="math math-display">
g(z) = {\mathrm{e}}^{z} f(z)
</span></p>
<p>因此必然满足</p>
<p><span class="math math-display">
f(z) = {\mathrm{e}}^{-z} g(z)
</span></p>
<p>其实更加优美的表达形式是</p>
<p><span class="math math-display">
b_n = \sum_{i = 0}^n (-1)^i\binom{n}{i} a_i
</span></p>
<h3>Stirling 反演</h3>
<p>注意当两个数列满足关系</p>
<p><span class="math math-display">
b_n = \sum_{k = 0}^n {n \brace k} a_k
</span></p>
<p>时，我们称其为 Stirling 变换，其 EGF 对应的有</p>
<p><span class="math math-display">
g(z) = f({\mathrm{e}}^z - 1)
</span></p>
<p>因此我们换元可以得到</p>
<p><span class="math math-display">
f(z) = g(\ln (1 + z))
</span></p>
<p>故得到 Stirling 反演公式</p>
<p><span class="math math-display">
a_n = \sum_{k = 0}^n (-1)^{n - k} {n \brack k} b_k
</span></p>
<h3>Codeforces 961G Partitions</h3>
<p>依据题意可直观推出一个式子</p>
<p><span class="math math-display">
\sum_{i = 1}^n i\binom{n-1}{i-1}{n-i \brace k-1}
</span></p>
<p>但是对于此题来说 <span class="math math-inline">n \le 2\times 10^5</span>，不能有效地进行计算。我们考虑式子已经具有卷积的可能，对其进行初等变形</p>
<p><span class="math math-display">
\begin{aligned}
a_n &amp; = \sum_{i = 1}^n i\binom{n-1}{i-1}{n-i \brace k-1} \\
&amp; = \sum_{i = 0}^n \frac{i^2}n\binom{n}{i}{n - i\brace k - 1} \\
&amp; = \frac{b_n}n \\
b_n &amp; = \sum_{i = 0}^n \left[i + i(i - 1) \right]\binom{n}{i}{n - i\brace k - 1} \\
B(z) &amp; = (z{\mathrm{e}}^z + z^2{\mathrm{e}}^z)\frac{({\mathrm{e}}^z - 1)^{k - 1}}{(k - 1)!} \\
B(z) &amp; = (z + z^2)\left[ k \frac{({\mathrm{e}}^z - 1)^k}{k!} + \frac{({\mathrm{e}}^z - 1)^{k - 1}}{(k - 1)!} \right] \\
b_n &amp; = kn\left[{n-1\brace k}+(n-1){n-2\brace k}\right] + n\left[{n-1\brace k-1}+(n-1){n-2\brace k-1}\right]\\
&amp; = n\left(k{n-1\brace k}+{n-1\brace k-1}\right) + n(n - 1)\left(k{n-2\brace k}+{n-2\brace k - 1}\right) \\
&amp; = n{n\brace k} + n(n-1){n - 1\brace k} \\
a_n &amp; = {n\brace k}+(n-1){n-1\brace k}
\end{aligned}
</span></p>
<h2>概率与期望</h2>
<p>生成函数可以辅助研究一类特殊的概率问题。</p>
<p>记发生事件所带来的效果为 <span class="math math-inline">n</span> 的概率为 <span class="math math-inline">p_n</span>，那么它的 OGF 即</p>
<p><span class="math math-display">
f(z) = \sum_{n = 0}^\infty p_nz^n
</span></p>
<p>有几个相关的意义</p>
<p><span class="math math-display">
f(1) = \sum_{n = 0}^\infty p_n = 1
</span></p>
<p>这一点必须满足。</p>
<p><span class="math math-display">
f&#39;(1) = \sum_{n = 0}^\infty np_n = \operatorname{mean}(f)
</span></p>
<p>代表这一事件的期望。</p>
<p>而方差是</p>
<p><span class="math math-display">
\begin{aligned}
\operatorname{var}(f) &amp;= \sum_{n = 0}^\infty p_n(n - \operatorname{mean}(f)) ^ 2 \\
&amp;= \sum_{n = 0}^\infty n^2p_n - \operatorname{mean}(f)^2 \\
&amp;= f&#39;&#39;(1) + f&#39;(1) - f&#39;(1)^2
\end{aligned}
</span></p>
<h2>解析组合 (Analytic Combinatorics)</h2>
<p>解析组合试图从一个较为机械化的方式帮助我们将组合计数问题从模型直接转为生成函数。</p>
<h3>组合类</h3>
<p>一个组合类 (Combinatorial Class) <span class="math math-inline">\mathcal A</span> 是一个有限集或可数集，即 <span class="math math-inline">|\mathcal A| \le \aleph_0</span>，并且集合中的每一个元素 <span class="math math-inline">\alpha</span> 我们赋予一个属性 <span class="math math-inline">|\alpha|</span> 为这个元素的“大小”。但我们要求</p>
<ul>
<li>每个元素的大小是一个非负整数。</li>
<li>对于每个非负整数 <span class="math math-inline">n</span>，以其为大小的元素是有限的。</li>
</ul>
<p>因此我们可以定义有限集 <span class="math math-inline">\mathcal A_n</span> 为所有大小为 <span class="math math-inline">n</span> 的元素的集合，而 <span class="math math-inline">A_n = |\mathcal A_n|</span>。</p>
<p>因此，在我们理解数列的普通型生成函数的时候，可以如此理解</p>
<p><span class="math math-display">
A(z) = \sum_{\alpha \in \mathcal A} z^{|\alpha|}
</span></p>
<p>形参 <span class="math math-inline">z</span> 刻画了元素的大小。</p>
<h3>运算</h3>
<p>当 <span class="math math-inline">\Phi</span> 将 <span class="math math-inline">m</span> 个组合类联系成一个组合类</p>
<p><span class="math math-display">
\mathcal A = \Phi \left[\mathcal B^{(1)}, \mathcal B^{(2)}, \dots, \mathcal B^{(m)}\right]
</span></p>
<p>且数列 <span class="math math-inline">A_n</span> 只与 <span class="math math-inline">B^{(1)}_n, B^{(2)}_n, \dots, B^{(m)}_n</span> 数列有关时，我们感兴趣的是转换方式即映射 <span class="math math-inline">\Phi</span> 对应的运算 <span class="math math-inline">\Psi</span></p>
<p><span class="math math-display">
A(z) = \Psi \left[B^{(1)}(z), B^{(2)}(z), \dots, B^{(m)}(z)\right]
</span></p>
<h4>笛卡尔积</h4>
<p>当一个类 <span class="math math-inline">\mathcal A</span> 由笛卡尔积 (Cartesian Product) 的方式生成的时候</p>
<p><span class="math math-display">
\mathcal A \cong \mathcal B \times \mathcal C = \{ \alpha = (\beta, \gamma) | \beta \in \mathcal B \wedge \gamma \in \mathcal C \}
</span></p>
<p>在一般情况下新元素的意义是</p>
<p><span class="math math-display">
|\alpha| = |\beta| + |\gamma|
</span></p>
<p>因此可以得到生成函数对应的是</p>
<p><span class="math math-display">
A(z) = B(z)C(z)
</span></p>
<h4>和</h4>
<p>当一个类 <span class="math math-inline">\mathcal A</span> 由两个类 <span class="math math-inline">\mathcal B, \mathcal C</span> 合并生成时（默认类与类之间没有共同部分，即 <span class="math math-inline">\mathcal B \cap \mathcal C = \emptyset</span>）</p>
<p>我们干脆称这个运算为 <span class="math math-inline">\mathcal A = \mathcal B + \mathcal C</span> 两个类的组合和 (Sum)</p>
<p>我们有</p>
<p><span class="math math-display">
A(z) = B(z) + C(z)
</span></p>
<h4>Catalan 数</h4>
<p>以二叉树的方式理解 Catalan 类 <span class="math math-inline">\mathcal C</span>，我们可以得到一个构造方式：</p>
<p>一个元素要么为空树，要么分为自己节点，左子树和右子树。因此我们可以列出组合类的自指构造过程</p>
<p><span class="math math-display">
\mathcal C = \{\epsilon\} + \mathcal C \times \mathcal Z \times \mathcal C
</span></p>
<p>默认记 <span class="math math-inline">\mathcal Z</span> 是一个单一元素类，只包含一个 <span class="math math-inline">|z| = 1</span>。</p>
<p>因此生成函数必然是</p>
<p><span class="math math-display">
C(z) = 1 + C(z)zC(z)
</span></p>
<h4>序列构造</h4>
<p>一个组合类 <span class="math math-inline">\mathcal A</span> 组成的不定长序列 (Sequence) 为</p>
<p><span class="math math-display">
\operatorname{SEQ}(\mathcal A) = \{ \epsilon \} + \mathcal A + \mathcal A \times \mathcal A + \cdots
</span></p>
<p>对应的生成函数</p>
<p><span class="math math-display">
\frac1{1 - A(z)}
</span></p>
<p>记 <span class="math math-display">Q[f] = \frac1{1 - f}</span></p>
<p>被称为 <span class="math math-inline">f</span> 的准逆元 (Quasi Inversion)</p>
<p>如果我们想要进行对有根树计数，且儿子有顺序则有</p>
<p><span class="math math-display">
\mathcal T = \mathcal Z \times \operatorname{SEQ}(\mathcal T)
</span></p>
<p>对应的 OGF 满足</p>
<p><span class="math math-display">
T(z) = \frac{z}{1 - T(z)}
</span></p>
<p>可以解得</p>
<p><span class="math math-display">
T(z) = \frac{1 - \sqrt{1- 4z}}2 = \sum_{n = 1}^\infty \frac{{2n - 2 \choose n - 1}}n z^n
</span></p>
<h4>幂集</h4>
<p>一个类的幂集 (Power Set) 即其集合的所有子集，枚举每个元素是否存在可以得到</p>
<p><span class="math math-display">
\operatorname{PSET}(\mathcal A) = \prod_{\alpha \in \mathcal A} (\{\epsilon\} + \{\alpha\})
</span></p>
<p>因此生成函数为</p>
<p><span class="math math-display">
\prod_{\alpha \in \mathcal A} (1 + z^{|\alpha|}) = \prod_{n = 0}^\infty (1 + z^n)^{A_n}
</span></p>
<p>另一种不含多项式系数的表示方法可以对式子先取 <span class="math math-inline">\ln</span> 再取 <span class="math math-inline">\exp</span></p>
<p><span class="math math-display">
\begin{aligned}
\prod_{n = 0}^\infty (1 + z^n)^{A_n}
&amp; = \exp\left( \sum_{n = 1}^\infty A_n \ln (1 + z^n)\right) \\
&amp; = \exp\left( \sum_{n = 1}^\infty A_n \sum_{k = 1}^\infty \frac{(-1)^{k - 1}}{k} z^{nk}\right) \\
&amp; = \exp\left( \sum_{k = 1}^\infty \frac{(-1)^{k - 1}}{k} \sum_{n = 1}^\infty A_n \cdot (z^k)^n \right) \\
&amp; = \exp\left( \sum_{k = 1}^\infty \frac{(-1)^{k - 1}}k A(z^k) \right)
\end{aligned}
</span></p>
<p>记</p>
<p><span class="math math-display">
\operatorname{\overline {Exp}} [f] = \exp\left( \sum_{k = 1}^\infty \frac{(-1)^{k - 1}}k f(z^k) \right)
</span></p>
<p>被称为改版 P'olya 指数 (Modified P'olya Exponential)</p>
<h4>多重集</h4>
<p>一个类的多重集 (Multiset) 则每个元素自成序列</p>
<p><span class="math math-display">
\operatorname{MSET}(\mathcal A) = \prod_{\alpha \in \mathcal A} \operatorname{SEQ}(\{\alpha\})
</span></p>
<p>因此生成函数是</p>
<p><span class="math math-display">
\prod_{n = 1}^\infty (1 - z^n)^{-A_n}
</span></p>
<p>类似可以证明它等于</p>
<p><span class="math math-display">
\exp\left(\sum_{k = 1}^\infty \frac{A(z^k)}{k}\right)
</span></p>
<p>记</p>
<p><span class="math math-display">
\operatorname{Exp} [f] = \exp\left(\sum_{k = 1}^\infty \frac{f(z^k)}{k}\right)
</span></p>
<p>这一运算被称为 P'olya 指数 (P'olya Exponential)</p>
<h4>圆排列</h4>
<p>圆排列 (Cycle) 或者说环 <span class="math math-inline">\operatorname{CYC}(\mathcal A)</span> 是对序列以平移操作进行去重。</p>
<p>注意到由 P'olya 定理，若环由 <span class="math math-inline">n</span> 个元素组成则对旋转变换群 <span class="math math-inline">R_n</span> 去重</p>
<p><span class="math math-display">
A_n(z) = \frac 1 n\sum_{d = 1}^n A\left(z^{\frac{n}{\gcd(n, d)}} \right)^{\gcd(n, d)}
</span></p>
<p>考虑到对 <span class="math math-inline">\gcd</span> 的结果统计</p>
<p><span class="math math-display">
A_n(z) = \frac1n \sum_{k = 1}^n \varphi(k) A(z^k)^{n/k}
</span></p>
<p><span class="math math-display">
\begin{aligned}
\sum_{n = 1}^\infty A_n(z) &amp; = \sum_{n = 1}^\infty \frac1n \sum_{k = 1}^n \varphi(k) A(z^k)^{n/k} \\
&amp; = \sum_{k = 1}^\infty \varphi(k) \sum_{m = 1}^\infty \frac 1{mk} A(z^k)^m\\
&amp; = \sum_{k = 1}^\infty \frac{\varphi(k)}k \ln \frac1{1 - A(z^k)}
\end{aligned}
</span></p>
<p>记</p>
<p><span class="math math-display">
\operatorname{Log} [f] = \sum_{k = 1}^\infty \frac{\varphi(k)}k \ln \frac1{1 - f(z^k)}
</span></p>
<p>被称为 P'olya 对数 (P'olya Logarithm)</p>
<h3>拆分</h3>
<p>一般来说，拆分是对于一个正整数集 <span class="math math-inline">\mathcal I = \mathcal Z + \mathcal Z^2 + \cdots</span> 的子集 <span class="math math-inline">\mathcal T \subseteq \mathcal I</span></p>
<h4>有序切分 (Composition)</h4>
<p>将一个数用 <span class="math math-inline">\mathcal T</span> 中的数有序拆分，记为 <span class="math math-inline">\mathcal C^{\mathcal T}</span></p>
<p>其实容易得到</p>
<p><span class="math math-display">
\mathcal C^{\mathcal T} = \operatorname{SEQ}(\mathcal T)
</span></p>
<p>故</p>
<p><span class="math math-display">
C^{\mathcal T}(z) = \frac1{1-T(z)}
</span></p>
<p>而注意到 Fibonacci 数便可以理解为 <span class="math math-inline">\mathcal T = \{1, 2\}</span> 的拆分。</p>
<h4>无序拆分 (Partition)</h4>
<p>记为 <span class="math math-inline">\mathcal P^{\mathcal T}</span></p>
<p><span class="math math-display">
\mathcal P^{\mathcal T} = \operatorname{MSET}(\mathcal T)
</span></p>
<p>有</p>
<p><span class="math math-display">
P^{\mathcal T}(z) = \prod_{n \in \mathcal T}\frac1{1-z^n}
</span></p>
<p>这类数一般难有通项公式，但有近似</p>
<p><span class="math math-display">
P^{(\le r)}_n \sim \frac{n^{r-1}}{r!(r-1)!}
</span></p>
<p>通过组合思维可以推导出一个不平凡的式子</p>
<p><span class="math math-display">
\prod_{n = 1}^\infty \frac 1{(1-z^n)} = \sum_{h = 0}^\infty \frac{z^{h^2}}{\prod_{k = 1}^h (1-z^k)^2}
</span></p>
<p>这是考虑将一个拆分排成一个图形，分割中间的中心正方形得到的。</p>
<p>所以我们得到了</p>
<p><span class="math math-display">
\mathcal P^{\mathcal I} = \bigcup_{h = 0}^\infty \mathcal P^{(\le h)} \mathcal Z^{h^2} \mathcal P^{(\le h)}
</span></p>
<p>还有一个有趣的应用可以证明：相异无序拆分等于奇无序拆分。</p>
<p>记 <span class="math math-inline">\mathcal Q, \mathcal O</span> 为互异数拆分方案和奇数拆分方案。</p>
<p><span class="math math-display">
\begin{aligned}
Q(z) &amp; = \prod_{n = 1}^\infty (1 + z^n) \\
O(z) &amp; = \frac1{1-z} \frac1{1-z^3} \frac1{1-z^5} \cdots
\end{aligned}
</span></p>
<p>只要发现 <span class="math math-inline">1 + z^n = \frac{1-z^{2n}}{1-z^n}</span>，因此</p>
<p><span class="math math-display">
\begin{aligned}
Q(z) &amp; = \frac{1-z^2}{1-z} \frac{1-z^4}{1-z^2} \frac{1-z^6}{1-z^3} \cdots \\
&amp; = \frac1{1-z} \frac1{1-z^3} \frac1{1-z^5} \cdots \\
&amp; = O(z)
\end{aligned}
</span></p>
<h4>环切分 (Cyclic Composition)</h4>
<p>环切分的一般情况较难分析，记 <span class="math math-inline">\mathcal D = \operatorname{CYC}(\mathcal I)</span>，我们有</p>
<p><span class="math math-display">
D(z) = \sum_{k = 1}^\infty \frac{\varphi(k)}{k}\ln \frac1{1 - \frac{z^k}{1-z^k}}
</span></p>
<p>暴力分析系数可以得到通项公式</p>
<p><span class="math math-display">
\begin{aligned}
D_n &amp;= \frac1n \sum_{k|n} \varphi(k)(2^\frac n k - 1) \\
&amp; = -1 + \frac1n \sum_{k|n} \varphi(k) 2^\frac n k
\end{aligned}
</span></p>
<h3>最长频次</h3>
<p>记一个单词 <span class="math math-inline">\mathcal W</span> 类中只有字符 <span class="math math-inline">a, b</span> 考虑其中 <span class="math math-inline">a</span> 的连续子段长度小于 <span class="math math-inline">k</span> ，被称为一个 Longest Run 的计数。</p>
<p>由</p>
<p><span class="math math-display">
\mathcal W = a_{&lt;k} \operatorname{SEQ}(b a_{&lt;k})
</span></p>
<p><span class="math math-display">
\begin{aligned}
W^{\langle k\rangle}(z) &amp; = \frac{1-z^k}{1-z} \cdot \frac1{1 - z\frac{1-z^k}{1-z}} \\
&amp; = \frac{1-z^k}{1-2z-z^{k+1}}
\end{aligned}
</span></p>
<p>推广地，如果字符集大小为 <span class="math math-inline">m</span> 则为</p>
<p><span class="math math-display">
\frac{1-z^k}{1-mz-(m-1)z^{k+1}}
</span></p>
<p>如果对 <span class="math math-inline">a, b</span> 均有限制 (Double Run)，则考虑将构造分解为</p>
<p><span class="math math-display">
\mathcal W^{\langle \alpha,\beta \rangle} = \operatorname{SEQ}_{\le \alpha}(a)\operatorname{SEQ}(b\operatorname{SEQ}_{&lt;\beta}(b)a\operatorname{SEQ}_{&lt;\alpha}(a))\operatorname{SEQ}_{\le\beta}(b)
</span></p>
<p>因此有</p>
<p><span class="math math-display">
W^{\langle \alpha,\beta \rangle}(z) = \frac{(1-z^{\alpha+1})(1-z^{\beta+1})}{(1-z)^2-z^2(1-z^\alpha)(1-z^\beta)}
</span></p>
<h3>自动机识别</h3>
<p>对于一个语言 <span class="math math-inline">\mathcal L</span>，有字符集 <span class="math math-inline">\mathcal A</span>，可行的字符串当且仅当可以被给定的确定性有限状态自动机 (DFA, Deterministic Finite-state Automaton) 识别。其中状态为 <span class="math math-inline">Q = \{q_0, q_1, \dots, q_s\}</span>，而被识别是到达终止节点 <span class="math math-inline">\overline Q</span> 中的某一个。</p>
<p><span class="math math-display">
L(z) = \mathbf u(I - zT)^{-1}\mathbf v^{\mathsf T}
</span></p>
<p>其中 <span class="math math-inline">u_i = 1</span> 代表 <span class="math math-inline">q_i</span> 是初始状态，<span class="math math-inline">v_i = 1</span> 代表 <span class="math math-inline">q_i \in \overline Q</span>，而 <span class="math math-inline">T_{i, j}</span> 表示有多少种字符可以使 <span class="math math-inline">i</span> 到 <span class="math math-inline">j</span>。</p>
<p>可以分状态讨论证明，设 <span class="math math-inline">\mathcal L_i</span> 是所有从 <span class="math math-inline">q_i</span> 出发的情况。</p>
<p><span class="math math-display">
\mathcal L_i = \Delta_i + \sum_{\alpha \in \mathcal A} \{\alpha\}\mathcal L_{q_i \cdot \alpha}
</span></p>
<p>当 <span class="math math-inline">q_i \in \overline Q</span> 时，<span class="math math-inline">\Delta_i = \{\epsilon\}</span>，否则为 <span class="math math-inline">\emptyset</span>。</p>
<p>事实上解这个方程就能得到这一结论。</p>
<p>例如匹配串 <span class="math math-inline">abb</span>，可以解得生成函数</p>
<p><span class="math math-display">
L(z) = \frac{z^3}{(1-z)(1-2z)(1-z-z^2)} = \frac1{1-2z} -\frac{2+z}{1-z-z^2} + \frac1{1-z}
</span></p>
<p>得到通项公式</p>
<p><span class="math math-display">
L_n = 2^n - F_{n + 3} + 1
</span></p>
<h2>狄利克雷级数</h2>
<p>狄利克雷级数 (Dirichlet Series) 的特点在于其级数的乘法对应的卷积是狄利克雷卷积。是指数级数，也可以认为是卷积为狄利克雷卷积的数列狄利克雷生成函数 (Dirichlet Generating Function)。</p>
<p><span class="math math-display">
\mathfrak D_w^A(s) = \sum_{\alpha \in A} \frac1{w(\alpha)^s} = \sum_{n=1}^\infty \frac {a_n}{n^s}
</span></p>
<p>发现在这个级数中，<span class="math math-inline">\langle 1, 1 \cdots \rangle</span> 对应的就是 Riemann Zeta 函数 <span class="math math-inline">\zeta(s) = \sum_{n=1}^\infty \frac 1{n^s}</span>。可以预见狄利克雷级数的演算可能用到大量复分析的知识，因此不太可能引入到实际比赛的题目中，但可以作为狄利克雷卷积更深刻的了解。</p>
<h3>质因子分解</h3>
<p>对于所有的积性数列来说，其狄利克雷级数可以分解成每个质因子指数基的级数乘积，不同的 <span class="math math-inline">p^k</span> 是正交的。</p>
<p>我们可以由此推导出一个式子</p>
<p><span class="math math-display">
\begin{aligned}
\sum_{n=1}^\infty \frac1{n^s} &amp; = \sum_{p_1^{k_1}p_2^{k_2}\cdots} \frac 1{p_1^{sk_1}p_2^{sk_2}\cdots} \\
&amp; = \left(\sum_{k_1 = 0}^\infty \frac1{p_1^{sk_1}}\right)\left(\sum_{k_2 = 0}^\infty \frac1{p_2^{sk_2}}\right)\cdots \\
&amp; = \prod_{p \in \mathbb P} \frac1{1 - p^{-s}}
\end{aligned}
</span></p>
<h3>Mobius 变换与反演</h3>
<p>事实上所有的 Mobius 变换在级数上的体现就是将一个函数乘以 <span class="math math-inline">\zeta(s)</span>，不难验证</p>
<p><span class="math math-display">
\frac 1{\zeta(s)} = \sum_{n=1}^\infty \frac{\mu(n)}{n^s} = \prod_{p \in \mathbb P}(1 - p^{-s})
</span></p>
<p>所以我们常用与反演的 M&amp;quot;obius 函数 <span class="math math-inline">\mu(n)</span> 当做数列，其级数就是 <span class="math math-inline">\zeta(s)</span> 的倒数函数。</p>
<h4>Euler 函数</h4>
<p>由欧拉函数满足恒等式</p>
<p><span class="math math-display">
\sum_{d|n} \varphi(d) = n
</span></p>
<p>而</p>
<p><span class="math math-display">
\sum_{n = 1}^\infty \frac{n}{n^s} = \sum_{n = 1}^\infty \frac1{n^{s - 1}} = \zeta(s - 1)
</span></p>
<p>可以得到</p>
<p><span class="math math-display">
\sum_{n = 1}^\infty \frac{\varphi(n)}{n^s} = \frac{\zeta(s - 1)}{\zeta(s)}
</span></p>
<h3>除数函数</h3>
<p><span class="math math-display">
\sum_{n = 1}^\infty \frac{\sigma_k(n)}{n^s} = \zeta(s - k)\zeta(s)
</span></p>
<h3>求导</h3>
<p>根据一些简单的求导知识我们可以得到</p>
<p><span class="math math-display">
f&#39;(s) = \sum_{n = 1}^\infty \frac{-a_n\ln n}{n^s}
</span></p>
<p>因此我们有</p>
<p><span class="math math-display">
-\frac{\zeta&#39;(s)}{\zeta(s)} = \sum_{n = 1}^\infty \frac{\Lambda(n)}{n^s}
</span></p>
<p>我们得到了 von Mangoldt 函数 <span class="math math-inline">\Lambda(n)</span></p>

  </div>
</article>
</main>
	<footer class="bg-stone-100 ">
	<div class="px-4 py-8" >
		<p class="flex items-center text-3 justify-center text-secondary">
			<span>© 2024 Roger Young</span>
			<span class="i-ph-lightning px-1"></span>
			<span>Powered by
				<a href="https://github.com/rogeryoungh/md-wiki-rs">MD Wiki</a>
			</span>
		</p>
	</div>
</footer>
</body>

</html>